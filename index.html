<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>CyGNSSnet Web View</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #f0f0f0;
      overflow: hidden;
    }

    #map {
      height: 100%;
      width: 100%;
      z-index: 1;
    }

    /* --- Analysis Panel (Right Side) --- */
    #analysis-panel {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 480px;
      max-height: calc(100vh - 20px);
      background: rgba(255, 255, 255, 0.98);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      transform: translateX(110%);
      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      border: 1px solid #ddd;
    }

    #analysis-panel.visible {
      transform: translateX(0);
    }

    #panel-header {
      padding: 12px 15px;
      background: #f8f9fa;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 8px 8px 0 0;
    }

    #panel-header h3 {
      margin: 0;
      font-size: 15px;
      color: #333;
      font-weight: 600;
    }

    #close-panel {
      cursor: pointer;
      font-size: 20px;
      color: #999;
      line-height: 1;
    }

    #close-panel:hover {
      color: #333;
    }

    #panel-content {
      padding: 0;
      overflow-y: auto;
      flex-grow: 1;
    }

    .section-header {
      padding: 10px 15px;
      background: #fafafa;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #777;
      font-weight: 700;
      border-bottom: 1px solid #eee;
      border-top: 1px solid #eee;
    }

    .section-header:first-child {
      border-top: none;
    }

    /* --- Compact Table Styling for Features --- */
    .analysis-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .analysis-table th {
      text-align: left;
      padding: 8px 12px;
      background: #fff;
      position: sticky;
      top: 0;
      z-index: 10;
      border-bottom: 2px solid #eee;
      color: #555;
      font-weight: 600;
    }

    .analysis-table td {
      padding: 4px 12px;
      border-bottom: 1px solid #f5f5f5;
      color: #333;
    }

    .analysis-table tr:hover {
      background-color: #f8f9fa;
    }

    .col-name {
      width: 35%;
      font-weight: 500;
    }

    .col-val {
      width: 20%;
      font-family: monospace;
      text-align: right;
    }

    .col-viz {
      width: 45%;
    }

    /* Histogram Bars in Table */
    .viz-container {
      width: 100%;
      height: 24px;
      display: flex;
      align-items: flex-end;
      position: relative;
    }

    .hist-bar {
      flex: 1;
      background: #e0e0e0;
      margin: 0 1px;
      transition: height 0.2s;
      min-width: 2px;
    }

    .val-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #000;
      z-index: 2;
      box-shadow: 0 0 2px rgba(255, 255, 255, 1);
    }

    /* --- DDM Grid --- */
    #ddm-container {
      padding: 15px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      background: #fff;
    }

    .ddm-box {
      background: #fff;
      border: 1px solid #eee;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      image-rendering: pixelated;
      /* Standard */
      image-rendering: crisp-edges;
      /* Firefox */
    }

    .ddm-box canvas {
      /* Force the canvas to fill the box while maintaining pixelation */
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .ddm-box-title {
      position: absolute;
      top: 5px;
      left: 5px;
      font-size: 10px;
      font-weight: bold;
      color: #333;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 4px;
      border-radius: 3px;
      z-index: 10;
      pointer-events: none;
    }

    .ddm-placeholder-art {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #aaa;
      font-size: 10px;
      text-align: center;
      background: #fcfcfc;
    }

    /* Plotly container adjustments */
    .js-plotly-plot {
      width: 100%;
      height: 100%;
    }

    /* --- Main UI Controls --- */
    #title {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 18px;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      pointer-events: none;
    }

    #controls {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(255, 255, 255, 0.98);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      width: 240px;
    }

    #controls label {
      font-size: 12px;
      font-weight: 600;
      color: #444;
      display: block;
      margin-bottom: 4px;
    }

    #controls select,
    #controls input[type="range"] {
      width: 100%;
      margin-bottom: 12px;
      padding: 4px;
      font-size: 13px;
    }

    /* --- Legend --- */
    #legend {
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      width: 140px;
      z-index: 1000;
    }

    #legend h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      text-align: center;
      color: #333;
    }

    #colorbar {
      height: 12px;
      width: 100%;
      border-radius: 2px;
      margin-bottom: 6px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .legend-values {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #555;
      font-family: monospace;
    }

    #zoom-note {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #eee;
      font-size: 11px;
      color: #666;
      line-height: 1.4;
    }

    kbd {
      background: #eee;
      border-radius: 3px;
      padding: 0 3px;
      border: 1px solid #ccc;
    }

    /* --- LCZ Legend --- */
    #lcz-legend-container {
      position: absolute;
      bottom: 25px;
      left: 10px;
      z-index: 1000;
    }

    #lcz-legend-toggle {
      background: rgba(255, 255, 255, 0.98);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 8px;
      text-align: center;
    }

    #lcz-legend-content {
      background: rgba(255, 255, 255, 0.98);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      width: 220px;
      max-height: 400px;
      overflow-y: auto;
      display: block;
    }

    #lcz-legend-content h5 {
      margin: 8px 0 4px 0;
      font-size: 12px;
      color: #444;
    }

    #lcz-legend-content ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #lcz-legend-content li {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
      color: #333;
    }

    .lcz-color-box {
      width: 14px;
      height: 14px;
      margin-right: 8px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 2px;
    }
  </style>
</head>

<body>
  <div id="title">CyGNSSnet Web View</div>

  <div id="controls">
    <label for="datasetSelect">Dataset Source:</label>
    <select id="datasetSelect">
      <option value="raw">Raw Features</option>
      <option value="shap">SHAP Values</option>
    </select>

    <div id="datasetNotesContainer">
      <label for="datasetNotes">Dataset Information:</label>
      <textarea id="datasetNotes" rows="4"
        style="width: 100%; font-size: 12px; padding: 4px; resize: vertical; font-family: inherit;"
        placeholder=></textarea>
    </div>

    <label for="featureSelect">Select Feature:</label>
    <select id="featureSelect"></select>

    <label for="opacitySlider">Layer Opacity:</label>
    <input id="opacitySlider" type="range" min="0" max="1" step="0.05" value="0.7">

    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
      <label style="display: flex; align-items: center; cursor: pointer;">
        <input type="checkbox" id="highlightDDM" style="width: auto; margin-right: 8px; margin-bottom: 0;">
        Highlight DDM Points
      </label>
    </div>
  </div>

  <div id="map"></div>

  <div id="legend">
    <h4>Data Legend</h4>
    <div id="colorbar"></div>
    <div class="legend-values">
      <span id="minVal">min</span>
      <span id="maxVal">max</span>
    </div>

    <div id="zoom-note">
      <b>Tip:</b> <kbd>Shift</kbd> + Drag to zoom area.
    </div>
  </div>

  <div id="lcz-legend-container">
    <div id="lcz-legend-toggle">Local Climate Zones (Hide)</div>
    <div id="lcz-legend-content">
      <div style="font-weight:bold; padding-bottom:5px; border-bottom:1px solid #ddd; margin-bottom:5px;">Legend Keys
      </div>
      <h5>Built Types</h5>
      <ul>
        <li><span class="lcz-color-box" style="background-color: #8C0000;"></span> 1 - Compact highrise</li>
        <li><span class="lcz-color-box" style="background-color: #D10000;"></span> 2 - Compact midrise</li>
        <li><span class="lcz-color-box" style="background-color: #FF0000;"></span> 3 - Compact lowrise</li>
        <li><span class="lcz-color-box" style="background-color: #BA6B00;"></span> 4 - Open highrise</li>
        <li><span class="lcz-color-box" style="background-color: #FF9E0D;"></span> 5 - Open midrise</li>
        <li><span class="lcz-color-box" style="background-color: #FFFF00;"></span> 6 - Open lowrise</li>
        <li><span class="lcz-color-box" style="background-color: #D8D8D8;"></span> 7 - Lightweight lowrise</li>
        <li><span class="lcz-color-box" style="background-color: #F0E3D1;"></span> 8 - Large lowrise</li>
        <li><span class="lcz-color-box" style="background-color: #838383;"></span> 9 - Sparsely built</li>
        <li><span class="lcz-color-box" style="background-color: #1A1A1A;"></span> 10 - Heavy industry</li>
      </ul>
      <h5>Land Cover Types</h5>
      <ul>
        <li><span class="lcz-color-box" style="background-color: #006A00;"></span> A - Dense trees</li>
        <li><span class="lcz-color-box" style="background-color: #009900;"></span> B - Scattered trees</li>
        <li><span class="lcz-color-box" style="background-color: #B4FF00;"></span> C - Bush, scrub</li>
        <li><span class="lcz-color-box" style="background-color: #D8FF8A;"></span> D - Low plants</li>
        <li><span class="lcz-color-box" style="background-color: #000000;"></span> E - Bare rock/paved</li>
        <li><span class="lcz-color-box" style="background-color: #F5EEBA;"></span> F - Bare soil/sand</li>
        <li><span class="lcz-color-box" style="background-color: #7AA2F9;"></span> G - Water</li>
      </ul>
    </div>
  </div>

  <div id="analysis-panel">
    <div id="panel-header">
      <h3 id="panel-title">Data Point Analysis</h3>
      <span id="close-panel">&times;</span>
    </div>
    <div id="panel-content">
      <div id="details-meta" style="padding: 15px; font-size: 13px; color: #666; font-style: italic;">
        Click a point on the map to view detailed feature analysis and DDMs.
      </div>

      <div class="section-header">Feature Distribution</div>

      <table class="analysis-table">
        <thead>
          <tr>
            <th class="col-name">Feature</th>
            <th class="col-val">Value</th>
            <th class="col-viz">Global Dist.</th>
          </tr>
        </thead>
        <tbody id="feature-table-body">
        </tbody>
      </table>

      <div class="section-header">Delay Doppler Maps (DDMs)</div>
      <div id="ddm-container">
      </div>
    </div>
  </div>

  <script>
    // --- Map Initialization ---
    const map = L.map('map', {
      boxZoom: true,
      minZoom: 2,
      worldCopyJump: true
    }).setView([20, 0], 2);

    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    const worldClim = L.tileLayer.wms("https://ows.worldclim.org/geoserver/wms", {
      layers: 'wc2.1_10m_tavg',
      format: 'image/png',
      transparent: true,
      opacity: 0.5,
      attribution: "WorldClim"
    });

    const lczLayer = L.tileLayer.wms("https://lcz-generator.rub.de/tms/global-map-tiles/latest/{z}/{x}/{y}.png", {
      interactive: false,
      opacity: 0.7,
      attribution: 'WUDAPT'
    }).addTo(map);

    const baseMaps = { "OpenStreetMap": osm };
    const overlayMaps = { "Local Climate Zones": lczLayer, "WorldClim Temp": worldClim };
    L.control.layers(baseMaps, overlayMaps).addTo(map);

    // --- Data Management ---
    const datasetFiles = {
      raw: 'raw_features.geojson',
      shap: 'shap_features.geojson'
    };

    // Mapping feature datasets to DDM datasets
    // Mapping feature datasets to DDM datasets
    const ddmFiles = {
      raw: 'ddm_raw.geojson',
      shap: 'ddm_shap.geojson'
    };

    // Color scales
    const scaleRaw = chroma.scale('Spectral').mode('lab');
    const scaleShap = chroma.scale(['#0074D9', '#ffffff', '#FF4136']).mode('lab');

    // Red Marker Icon (Google Maps style)
    const redIcon = new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    let geojsonLayer = null;
    let geoData = null;
    let ddmData = null; // Store DDM features
    let currentDataset = 'raw';
    let currentFeature = null;
    let featureStats = {};
    let selectedMarker = null; // Track selected point marker

    // DOM Elements
    const datasetSelect = document.getElementById('datasetSelect');
    const featureSelect = document.getElementById('featureSelect');
    const colorbar = document.getElementById('colorbar');
    const datasetNotesContainer = document.getElementById('datasetNotesContainer');
    const datasetNotes = document.getElementById('datasetNotes');

    const minVal = document.getElementById('minVal');
    const maxVal = document.getElementById('maxVal');
    const opacitySlider = document.getElementById('opacitySlider');
    const analysisPanel = document.getElementById('analysis-panel');
    const closePanelBtn = document.getElementById('close-panel');
    const featureTableBody = document.getElementById('feature-table-body');
    const detailsMeta = document.getElementById('details-meta');
    const highlightDDMCheckbox = document.getElementById('highlightDDM');

    // --- Event Listeners ---
    opacitySlider.addEventListener('input', () => {
      lczLayer.setOpacity(opacitySlider.value);
      worldClim.setOpacity(opacitySlider.value);
    });

    let datasetInfo = {};

    // Fetch external dataset info
    fetch('dataset_info.json')
      .then(r => r.json())
      .then(data => {
        datasetInfo = data;
        // Trigger initial update
        datasetSelect.dispatchEvent(new Event('change'));
      })
      .catch(err => console.warn('Could not load dataset_info.json', err));

    datasetSelect.addEventListener('change', () => {
      currentDataset = datasetSelect.value;
      datasetNotesContainer.style.display =
        (currentDataset === 'raw' || currentDataset === 'shap') ? 'block' : 'none';

      // Load text from external JSON
      if (datasetInfo[currentDataset]) {
        datasetNotes.value = datasetInfo[currentDataset];
      } else {
        datasetNotes.value = '';
      }
      datasetNotes.readOnly = true;
      loadDataset();
    });

    datasetNotesContainer.style.display = 'block';

    featureSelect.addEventListener('change', () => {
      currentFeature = featureSelect.value;
      updateColors();
    });

    closePanelBtn.addEventListener('click', () => {
      analysisPanel.classList.remove('visible');
      if (selectedMarker) {
        map.removeLayer(selectedMarker);
        selectedMarker = null;
      }
    });

    highlightDDMCheckbox.addEventListener('change', () => {
      if (geojsonLayer) {
        updateColors();
      }
    });

    // --- Core Logic ---

    function loadDataset() {
      const featFile = datasetFiles[currentDataset];
      const ddmFile = ddmFiles[currentDataset];

      // Feedback while loading
      minVal.textContent = "...";
      maxVal.textContent = "...";
      ddmData = null; // Reset DDM data

      // 1. Fetch MAIN Features
      const pFeatures = fetch(featFile).then(r => {
        if (!r.ok) throw new Error(`Features file ${featFile} not found`);
        return r.json();
      });

      // 2. Fetch DDM Features (Simultaneously)
      // We catch errors here so the main map still loads even if DDM is missing
      const pDDM = fetch(ddmFile)
        .then(r => {
          if (!r.ok) throw new Error(`DDM file ${ddmFile} not found`);
          return r.json();
        })
        .catch(err => {
          console.warn("DDM File loading failed (expected if file doesn't exist yet):", err);
          return null; // Return null on failure
        });

      // Wait for both
      Promise.all([pFeatures, pDDM])
        .then(([data, ddmResult]) => {
          // Handle Features
          geoData = data;
          ddmData = ddmResult; // Store the DDM geojson (or null)

          if (geojsonLayer) map.removeLayer(geojsonLayer);
          if (!data.features || data.features.length === 0) return;

          // ... [Stats Calculation Logic matches previous] ...
          const props = data.features[0].properties;
          const numericKeys = Object.keys(props).filter(k => typeof props[k] === 'number');

          featureStats = {};
          numericKeys.forEach(key => {
            // Fix: Avoid spread operator on large arrays (causes stack overflow on 200k+ items)
            const values = data.features.map(f => f.properties[key]);
            // Sort values to calculate robust limits (percentiles)
            values.sort((a, b) => a - b);
            const count = values.length;
            const q02 = values[Math.floor(count * 0.02)];
            const q98 = values[Math.floor(count * 0.98)];

            // Still track absolute min/max for other uses
            const min = values[0];
            const max = values[count - 1];

            // Use robust range for binning to avoid outlier skew
            const robustMin = q02;
            const robustMax = q98;

            const bins = 20;
            const range = robustMax - robustMin;
            const binCounts = new Array(bins).fill(0);

            // Calculate outliers
            let outliersLow = 0;
            let outliersHigh = 0;

            if (range > 0) {
              values.forEach(v => {
                if (v < robustMin) { outliersLow++; return; }
                if (v > robustMax) { outliersHigh++; return; }

                let idx = Math.floor(((v - robustMin) / range) * bins);
                if (idx >= bins) idx = bins - 1;
                binCounts[idx]++;
              });
            } else {
              binCounts[10] = values.length;
            }

            const maxCount = Math.max(...binCounts);
            const normBins = binCounts.map(c => maxCount ? c / maxCount : 0);
            featureStats[key] = { min, max, q02, q98, bins: normBins, outliers: { low: outliersLow, high: outliersHigh } };
          });

          // Update Dropdown
          featureSelect.innerHTML = "";
          const suffix = currentDataset === "raw" ? "_raw" : "_shap";

          numericKeys.sort();
          numericKeys.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            opt.textContent = k + suffix;
            featureSelect.appendChild(opt);
          });

          if (!currentFeature || !featureStats[currentFeature]) {
            currentFeature = numericKeys[0];
          }
          featureSelect.value = currentFeature;

          // --- MATCHING LOGIC ---
          // Use Brute Force Nearest Neighbor matching
          // 500 DDM points x 30,000 Main points = ~15 million ops (fast enough, <100ms)
          // This allows for matching even if coordinates are slightly offset (e.g. 1-2 degrees)

          let ddmMatchCount = 0;
          const featureToDDM = new Map();

          if (ddmData && ddmData.features) {
            const ddmFeats = ddmData.features;
            const mainFeats = geoData.features;

            ddmFeats.forEach((dFeat, dIdx) => {
              if (!dFeat.geometry || !dFeat.geometry.coordinates) return;
              const [dx, dy] = dFeat.geometry.coordinates;

              let minDist = 5.0; // Max threshold squared (sqrt(5) ~ 2.2 degrees)
              let bestMainIdx = -1;

              for (let mIdx = 0; mIdx < mainFeats.length; mIdx++) {
                const mFeat = mainFeats[mIdx];
                if (!mFeat.geometry || !mFeat.geometry.coordinates) continue;
                const [mx, my] = mFeat.geometry.coordinates;
                const d2 = (dx - mx) ** 2 + (dy - my) ** 2;

                if (d2 < minDist) {
                  minDist = d2;
                  bestMainIdx = mIdx;
                }
              }

              if (bestMainIdx !== -1) {
                featureToDDM.set(bestMainIdx, dIdx);
                ddmMatchCount++;
              }
            });
          }

          console.log(`Matched ${ddmMatchCount} DDM points to Main features.`);

          let featureIndex = 0;
          const myRenderer = L.canvas({ padding: 0.5 });

          geojsonLayer = L.geoJSON(geoData, {
            pointToLayer: (feature, latlng) => {
              const currentIdx = featureIndex++;
              feature.properties._featureIndex = currentIdx;

              const ddmIdx = featureToDDM.get(currentIdx);
              feature.properties._ddmIndex = ddmIdx;

              return L.circleMarker(latlng, {
                radius: 6,
                color: '#333',
                weight: 1,
                fillOpacity: 0.9,
                renderer: myRenderer
              });
            },
            onEachFeature: (feature, layer) => {
              layer.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                showFeatureAnalysis(feature.properties, feature.geometry.coordinates);
              });
            }
          }).addTo(map);

          updateColors();

          if (highlightDDMCheckbox.checked) {
            highlightDDMCheckbox.dispatchEvent(new Event('change'));
          }
        })
        .catch(err => {
          console.error(err);
          // alert(`Error loading data. See console for details.`);
        });
    }

    function updateColors() {
      if (!geojsonLayer || !currentFeature || !featureStats[currentFeature]) return;

      const { min, max, q02, q98 } = featureStats[currentFeature];
      // Show robust limits in legend
      minVal.textContent = q02.toFixed(4);
      maxVal.textContent = q98.toFixed(4);

      const activeScale = currentDataset === 'shap' ? scaleShap : scaleRaw;

      // Use robust limits for domain
      const domain = currentDataset === 'shap'
        ? [-Math.max(Math.abs(q02), Math.abs(q98)), Math.max(Math.abs(q02), Math.abs(q98))]
        : [q02, q98];

      geojsonLayer.eachLayer(layer => {
        const val = layer.feature.properties[currentFeature];
        let color;

        let t;
        if (currentDataset === 'shap') {
          const domMax = domain[1];
          // Clamp value
          let v = val;
          if (v < -domMax) v = -domMax;
          if (v > domMax) v = domMax;
          t = (v + domMax) / (2 * domMax);
        } else {
          // Clamp value
          let v = val;
          if (v < q02) v = q02;
          if (v > q98) v = q98;
          t = (q98 === q02) ? 0.5 : (v - q02) / (q98 - q02);
        }
        color = activeScale(t).hex();

        // Preserve highlight style during color update
        const isHighlight = highlightDDMCheckbox.checked;
        const hasDDM = layer.feature.properties._ddmIndex !== undefined;

        let alpha = opacitySlider.value;
        let radius = 6;
        let stroke = false;
        let weight = 1;
        let borderColor = '#333';

        if (isHighlight) {
          if (hasDDM) {
            alpha = 1.0;
            radius = 10;
            stroke = true;
            weight = 2;
            borderColor = '#00FFFF'; // Cyan highlight
            layer.bringToFront();
          } else {
            alpha = 0.1;
            radius = 3;
          }
        }

        layer.setStyle({
          fillColor: color,
          fillOpacity: alpha,
          radius: radius,
          stroke: stroke,
          color: borderColor,
          weight: weight
        });
      });

      const ctx = document.createElement('canvas').getContext('2d');
      const gradient = [];
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        gradient.push(activeScale(t).hex());
      }
      colorbar.style.background = `linear-gradient(to right, ${gradient.join(',')})`;
    }

    function showFeatureAnalysis(properties, coords) {
      analysisPanel.classList.add('visible');

      // Update Red Marker
      if (selectedMarker) {
        map.removeLayer(selectedMarker);
      }
      // Note: coords are [lng, lat] (GeoJSON), Leaflet needs [lat, lng]
      const latLng = [coords[1], coords[0]];
      selectedMarker = L.marker(latLng, { icon: redIcon, zIndexOffset: 1000 }).addTo(map);

      const ddmIdx = properties._ddmIndex; // Get linked index
      const featureIdx = properties._featureIndex;

      detailsMeta.innerHTML = `
        <strong>Coordinates:</strong> ${coords[1].toFixed(4)}, ${coords[0].toFixed(4)} <br>
        <strong>Dataset:</strong> ${currentDataset.toUpperCase()} Values <br>
        <strong>DDM Available:</strong> ${ddmIdx !== undefined ? 'Yes' : 'No'}
      `;

      featureTableBody.innerHTML = '';
      const ddmContainer = document.getElementById('ddm-container');
      ddmContainer.innerHTML = ''; // Clear previous

      // --- 1. Populate Table (Same as before) ---
      const numericKeys = Object.keys(properties).filter(k => typeof properties[k] === 'number' && !k.startsWith('_'));
      numericKeys.sort((a, b) => Math.abs(properties[b]) - Math.abs(properties[a]));

      numericKeys.forEach(key => {
        const val = properties[key];
        const stats = featureStats[key];
        if (!stats) return;

        const tr = document.createElement('tr');
        const tdName = document.createElement('td');
        tdName.className = 'col-name';
        tdName.textContent = key + (currentDataset === 'raw' ? '_raw' : '_shap');
        tr.appendChild(tdName);

        const tdVal = document.createElement('td');
        tdVal.className = 'col-val';
        tdVal.textContent = val.toFixed(4);
        tr.appendChild(tdVal);

        const tdViz = document.createElement('td');
        tdViz.className = 'col-viz';
        const vizCont = document.createElement('div');
        vizCont.className = 'viz-container';

        const { min, max, q02, q98, bins } = stats;
        bins.forEach(h => {
          const bar = document.createElement('div');
          bar.className = 'hist-bar';
          bar.style.height = (h * 100) + '%';
          // Highlight outlier bars? No, keep simple.
          if (currentDataset === 'shap') bar.style.backgroundColor = '#ccc';
          vizCont.appendChild(bar);
        });

        const marker = document.createElement('div');
        marker.className = 'val-marker';

        // Use robust range for marker position but allow overshooting (clamped visually)
        const robustMin = q02;
        const robustMax = q98;
        const range = robustMax - robustMin;

        let pct = 50;
        if (range !== 0) pct = ((val - robustMin) / range) * 100;

        // Marker indicates robust range pos, <0 or >100 is outlier
        if (pct < 0) pct = 0; // Stick to left edge
        if (pct > 100) pct = 100; // Stick to right edge

        marker.style.left = pct + '%';

        if (currentDataset === 'shap') {
          marker.style.background = val >= 0 ? '#FF4136' : '#0074D9';
          marker.style.width = '3px';
        }
        vizCont.appendChild(marker);
        tdViz.appendChild(vizCont);
        tr.appendChild(tdViz);
        featureTableBody.appendChild(tr);
      });

      // --- 2. DDM Rendering ---
      const ddmNames = ['DDM BRCS', 'DDM Power Analog', 'DDM Raw Counts', 'DDM Eff. Scatter'];

      // Check if we have DDM data loaded and if the index is valid
      let hasDDM = false;
      let ddmValues = [];

      if (ddmData && ddmIdx !== undefined && ddmData.features[ddmIdx]) {
        // Look for 'ddm_values' property (created by Python script)
        const props = ddmData.features[ddmIdx].properties;
        if (props && props.ddm_values) {
          ddmValues = props.ddm_values;
          hasDDM = true;
        }
      }

      ddmNames.forEach((name, i) => {
        const box = document.createElement('div');
        box.className = 'ddm-box';

        const title = document.createElement('div');
        title.className = 'ddm-box-title';
        title.textContent = name;
        box.appendChild(title);

        if (hasDDM) {
          // SLICE data for this specific DDM
          // Total 748 points. 4 DDMs. 187 points per DDM.
          // Shape 17 rows (height), 11 cols (width).
          const valuesPerDDM = 187;
          const start = i * valuesPerDDM;
          const end = start + valuesPerDDM;
          const slice = ddmValues.slice(start, end);

          // Check if slice has data
          if (slice.length < valuesPerDDM) {
            const errDiv = document.createElement('div');
            errDiv.textContent = "Incomplete Data";
            errDiv.className = 'ddm-placeholder-art';
            box.appendChild(errDiv);
            ddmContainer.appendChild(box);
            return;
          }

          // --- CANVAS IMPLEMENTATION ---
          // 11x17 logical pixels
          const canvas = document.createElement('canvas');
          canvas.width = 11;
          canvas.height = 17;

          box.appendChild(canvas);

          const ctx = canvas.getContext('2d');

          // Determine color scale and domain
          // For DDM, user requested 'viridis' (continuous) to show values.
          // We calculate local Min/Max for THIS specific DDM slice to maximize contrast.
          let localMin = Infinity;
          let localMax = -Infinity;

          for (let k = 0; k < slice.length; k++) {
            if (slice[k] < localMin) localMin = slice[k];
            if (slice[k] > localMax) localMax = slice[k];
          }

          // If flat, pad slightly
          if (localMax === localMin) {
            localMax += 0.0001;
          }

          // Use Viridis scale
          const ddmScale = chroma.scale('viridis').domain([localMin, localMax]);

          // Draw pixels 1x1
          // Data is assumed row-major: Top row (0), then next row...
          // Index 0..10 -> Row 0, Cols 0..10
          for (let r = 0; r < 17; r++) {
            for (let c = 0; c < 11; c++) {
              const val = slice[r * 11 + c];

              if (val === undefined) continue;

              ctx.fillStyle = ddmScale(val).hex();
              ctx.fillRect(c, r, 1, 1);
            }
          }

        } else {
          // Fallback Placeholder
          const art = document.createElement('div');
          art.className = 'ddm-placeholder-art';
          art.innerHTML = 'No DDM Data';
          box.appendChild(art);
        }

        ddmContainer.appendChild(box);
      });
    }

    // LCZ Legend Toggle
    const lczToggle = document.getElementById('lcz-legend-toggle');
    const lczContent = document.getElementById('lcz-legend-content');
    let isLczVisible = true;

    lczToggle.addEventListener('click', () => {
      isLczVisible = !isLczVisible;
      lczContent.style.display = isLczVisible ? 'block' : 'none';
      lczToggle.textContent = isLczVisible ? 'Local Climate Zones (Hide)' : 'Local Climate Zones (Show)';
    });

    // Initial Load
    loadDataset();

  </script>
</body>

</html>